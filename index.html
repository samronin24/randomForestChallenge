<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Random Forest Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Random Forest Challenge</h1>
<p class="subtitle lead">The Power of Weak Learners</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="random-forest-challenge---the-power-of-weak-learners" class="level1">
<h1>üå≤ Random Forest Challenge - The Power of Weak Learners</h1>
<section id="the-problem-can-many-weak-learners-beat-one-strong-learner" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-can-many-weak-learners-beat-one-strong-learner">The Problem: Can Many Weak Learners Beat One Strong Learner?</h2>
<p><strong>Core Question:</strong> How does the number of trees in a random forest affect predictive accuracy, and how do random forests compare to simpler approaches like linear regression?</p>
<p><strong>The Challenge:</strong> Individual decision trees are ‚Äúweak learners‚Äù with limited predictive power. Random forests combine many weak trees to create a ‚Äústrong learner‚Äù that generalizes better. But how many trees do we need? Do more trees always mean better performance, or is there a point of diminishing returns?</p>
<p><strong>Our Approach:</strong> We‚Äôll compare random forests with different numbers of trees against linear regression and individual decision trees to understand the trade-offs between complexity and performance <strong>for this dataset</strong>.</p>
<section id="python" class="level3">
<h3 class="anchored" data-anchor-id="python">Python</h3>
<div id="performance-comparison-python" class="cell" data-fig-height="6" data-fig-width="10" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import necessary libraries</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestRegressor</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error, r2_score</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_regression</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create sample dataset</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> make_regression(n_samples<span class="op">=</span><span class="dv">1000</span>, n_features<span class="op">=</span><span class="dv">10</span>, noise<span class="op">=</span><span class="fl">0.1</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create random forest models with different numbers of trees</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>rf_1 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">1</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>rf_5 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">5</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>rf_25 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">25</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>rf_100 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">100</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>rf_500 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">500</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>rf_1000 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">1000</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>rf_2000 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">2000</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>rf_5000 <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span><span class="dv">5000</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit the models</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>rf_1.fit(X_train, y_train)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>rf_5.fit(X_train, y_train)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>rf_25.fit(X_train, y_train)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>rf_100.fit(X_train, y_train)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>rf_500.fit(X_train, y_train)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>rf_1000.fit(X_train, y_train)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>rf_2000.fit(X_train, y_train)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>rf_5000.fit(X_train, y_train)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate predictions for test data</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>predictions_1_test <span class="op">=</span> rf_1.predict(X_test)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>predictions_5_test <span class="op">=</span> rf_5.predict(X_test)</span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>predictions_25_test <span class="op">=</span> rf_25.predict(X_test)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>predictions_100_test <span class="op">=</span> rf_100.predict(X_test)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>predictions_500_test <span class="op">=</span> rf_500.predict(X_test)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>predictions_1000_test <span class="op">=</span> rf_1000.predict(X_test)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>predictions_2000_test <span class="op">=</span> rf_2000.predict(X_test)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>predictions_5000_test <span class="op">=</span> rf_5000.predict(X_test)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate predictions for training data</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>predictions_1_train <span class="op">=</span> rf_1.predict(X_train)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>predictions_5_train <span class="op">=</span> rf_5.predict(X_train)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>predictions_25_train <span class="op">=</span> rf_25.predict(X_train)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>predictions_100_train <span class="op">=</span> rf_100.predict(X_train)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>predictions_500_train <span class="op">=</span> rf_500.predict(X_train)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>predictions_1000_train <span class="op">=</span> rf_1000.predict(X_train)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>predictions_2000_train <span class="op">=</span> rf_2000.predict(X_train)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>predictions_5000_train <span class="op">=</span> rf_5000.predict(X_train)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate performance metrics for test data</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>rmse_1_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_1_test))</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>rmse_5_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_5_test))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>rmse_25_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_25_test))</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>rmse_100_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_100_test))</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>rmse_500_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_500_test))</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>rmse_1000_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_1000_test))</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>rmse_2000_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_2000_test))</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>rmse_5000_test <span class="op">=</span> np.sqrt(mean_squared_error(y_test, predictions_5000_test))</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate performance metrics for training data</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>rmse_1_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_1_train))</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>rmse_5_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_5_train))</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>rmse_25_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_25_train))</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>rmse_100_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_100_train))</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>rmse_500_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_500_train))</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>rmse_1000_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_1000_train))</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>rmse_2000_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_2000_train))</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>rmse_5000_train <span class="op">=</span> np.sqrt(mean_squared_error(y_train, predictions_5000_train))</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>r2_1 <span class="op">=</span> r2_score(y_test, predictions_1_test)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>r2_5 <span class="op">=</span> r2_score(y_test, predictions_5_test)</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>r2_25 <span class="op">=</span> r2_score(y_test, predictions_25_test)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>r2_100 <span class="op">=</span> r2_score(y_test, predictions_100_test)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>r2_500 <span class="op">=</span> r2_score(y_test, predictions_500_test)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>r2_1000 <span class="op">=</span> r2_score(y_test, predictions_1000_test)</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>r2_2000 <span class="op">=</span> r2_score(y_test, predictions_2000_test)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>r2_5000 <span class="op">=</span> r2_score(y_test, predictions_5000_test)</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Create performance comparison</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>performance_data <span class="op">=</span> {</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Trees'</span>: [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">25</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">2000</span>, <span class="dv">5000</span>],</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="st">'RMSE_Test'</span>: [rmse_1_test, rmse_5_test, rmse_25_test, rmse_100_test, rmse_500_test, rmse_1000_test, rmse_2000_test, rmse_5000_test],</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>    <span class="st">'RMSE_Train'</span>: [rmse_1_train, rmse_5_train, rmse_25_train, rmse_100_train, rmse_500_train, rmse_1000_train, rmse_2000_train, rmse_5000_train],</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    <span class="st">'R_squared'</span>: [r2_1, r2_5, r2_25, r2_100, r2_500, r2_1000, r2_2000, r2_5000]</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>performance_df <span class="op">=</span> pd.DataFrame(performance_data)</span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(performance_df)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Trees  RMSE_Test  RMSE_Train  R_squared
0      1  93.350318   52.878686   0.483480
1      5  64.060456   29.790452   0.756759
2     25  53.042130   22.346755   0.833238
3    100  50.940026   20.240502   0.846194
4    500  50.425413   19.574998   0.849286
5   1000  50.603264   19.457569   0.848221
6   2000  50.450946   19.460667   0.849133
7   5000  50.663500   19.414942   0.847859</code></pre>
</div>
</div>
<p>:::</p>
</section>
</section>
<section id="student-analysis-section" class="level2">
<h2 class="anchored" data-anchor-id="student-analysis-section">Student Analysis Section: The Power of More Trees</h2>
<p><strong>Your Task:</strong> Create visualizations and analysis to demonstrate the power of ensemble learning. You‚Äôll need to create three key components:</p>
<section id="the-power-of-more-trees-visualization" class="level3">
<h3 class="anchored" data-anchor-id="the-power-of-more-trees-visualization">1. The Power of More Trees Visualization</h3>
<p><strong>Create a visualization showing:</strong> - RMSE vs Number of Trees (both training and test data) - R-squared vs Number of Trees - Do not <code>echo</code> the code that creates the visualization</p>
<div id="cell-power-of-trees-visualization" class="cell" data-fig-height="8" data-fig-width="12" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/power-of-trees-visualization-output-1.png" id="power-of-trees-visualization" width="1141" height="563" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Analysis: The Power of Ensemble Learning and Diminishing Returns</strong></p>
<p>The visualization reveals several key insights about how random forest performance improves with more trees, demonstrating fundamental principles of ensemble learning:</p>
<p><strong>Dramatic Early Improvements:</strong> The most significant performance gains occur in the first 25-100 trees. This dramatic improvement reflects the core principle of ensemble learning: combining multiple weak learners (individual decision trees) creates a strong learner. Each additional tree in this early range contributes substantially to reducing prediction variance and improving generalization.</p>
<p><strong>The Bootstrap Aggregation Effect:</strong> Random forests use bootstrap sampling (bagging) to create diversity among trees. With only 1-5 trees, the ensemble lacks sufficient diversity to capture the full complexity of the data. As we add more trees (25-100), we see the ‚Äúwisdom of crowds‚Äù effect - each tree votes on the prediction, and the ensemble‚Äôs decision becomes more robust and accurate.</p>
<p><strong>Diminishing Returns Beyond 100 Trees:</strong> After approximately 100 trees, the performance improvements become increasingly marginal. This demonstrates the principle of diminishing returns in ensemble learning. The additional trees provide less new information because: - The bootstrap samples become more similar as we add trees - The random feature selection has already explored most meaningful feature combinations - The ensemble has reached a point where additional trees primarily reduce variance rather than bias</p>
<p><strong>Training vs Test Performance Gap:</strong> The gap between training and test RMSE remains relatively stable across different tree counts, indicating that random forests maintain good generalization even with many trees. This contrasts with individual decision trees, which would show increasing overfitting with complexity.</p>
<p><strong>Practical Implications:</strong> The analysis suggests that 100-500 trees often provide the optimal balance between performance and computational efficiency. Beyond 1000 trees, the computational cost typically outweighs the marginal performance gains, making larger ensembles impractical for most real-world applications.</p>
<p>This demonstrates why random forests are so powerful: they transform weak individual learners into a strong ensemble through the principles of diversity, voting, and bootstrap aggregation, with the most dramatic improvements occurring in the early stages of ensemble building.</p>
</section>
<section id="overfitting-visualization-and-analysis" class="level3">
<h3 class="anchored" data-anchor-id="overfitting-visualization-and-analysis">2. Overfitting Visualization and Analysis</h3>
<p><strong>Your Task:</strong> Compare decision trees vs random forests in terms of overfitting.</p>
<p><strong>Create one visualization with two side-by-side plots showing:</strong> - Decision trees: How performance changes with tree complexity (max depth) - Random forests: How performance changes with number of trees</p>
<div id="cell-overfitting-comparison" class="cell" data-fig-height="6" data-fig-width="14" data-execution_count="3">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/overfitting-comparison-output-1.png" id="overfitting-comparison" width="1333" height="563" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Analysis: Why Random Forests Don‚Äôt Overfit Like Individual Trees</strong></p>
<p>The side-by-side comparison reveals fundamental differences in how decision trees and random forests handle complexity:</p>
<p><strong>Decision Trees: The Overfitting Problem</strong> Individual decision trees show classic overfitting behavior as complexity increases. The training RMSE continues to decrease (approaching zero) while test RMSE increases after a certain point. This occurs because: - <strong>High Variance</strong>: Individual trees can memorize training data with deep splits - <strong>No Regularization</strong>: Without constraints, trees can create overly specific rules - <strong>Single Path Decisions</strong>: Each prediction follows one path, making the model brittle to noise</p>
<p><strong>Random Forests: The Overfitting Solution</strong> Random forests maintain stable performance even with many trees. The training and test RMSE curves remain close together, demonstrating excellent generalization. This occurs through three key mechanisms:</p>
<ol type="1">
<li><strong>Bootstrap Sampling (Bagging)</strong>: Each tree trains on a different subset of data, preventing memorization of the entire training set</li>
<li><strong>Random Feature Selection</strong>: Each split considers only a random subset of features, reducing correlation between trees</li>
<li><strong>Averaging Predictions</strong>: The final prediction averages across many diverse trees, smoothing out individual tree errors</li>
</ol>
<p><strong>The Ensemble Effect</strong> The gap between training and test performance remains stable in random forests because: - Individual trees are diverse enough to capture different patterns - No single tree can overfit to the entire training set - The averaging process reduces variance while maintaining bias</p>
<p><strong>Practical Implications</strong> This analysis demonstrates why random forests are preferred over individual decision trees for most real-world applications. Random forests provide the interpretability benefits of tree-based models while avoiding the overfitting pitfalls that plague individual trees.</p>
</section>
<section id="linear-regression-vs-random-forest-comparison" class="level3">
<h3 class="anchored" data-anchor-id="linear-regression-vs-random-forest-comparison">3. Linear Regression vs Random Forest Comparison</h3>
<p><strong>Your Task:</strong> Compare random forests to linear regression baseline.</p>
<p><strong>Create a comparison table showing:</strong> - Linear Regression RMSE - Random Forest (1 tree) RMSE<br>
- Random Forest (100 trees) RMSE - Random Forest (1000 trees) RMSE</p>
<p><strong>Your analysis should address:</strong> - The improvement in RMSE when going from 1 tree to 100 trees - Whether switching from linear regression to 100-tree random forest shows similar improvement - When random forests are worth the added complexity vs linear regression - The trade-offs between interpretability and performance</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>üìä Comparison Requirements
</div>
</div>
<div class="callout-body-container callout-body">
<p>Create a clear table comparing:</p>
<ul>
<li>Linear Regression</li>
<li>Random Forest (1 tree)</li>
<li>Random Forest (100 trees)</li>
<li>Random Forest (1000 trees)</li>
</ul>
<p>Include percentage improvements over linear regression for each random forest model.</p>
</div>
</div>
<p><strong>This is an investigative report, not a coding exercise.</strong> You‚Äôre analyzing random forest models and reporting your findings like a professional analyst would. Think of this as a brief you‚Äôd write for a client or manager about the power of ensemble learning and when to use random forests vs simpler approaches.</p>
<p><strong>What makes a great report:</strong></p>
<ul>
<li><strong>Clear narrative:</strong> Tell the story of what you discovered about ensemble learning</li>
<li><strong>Insightful analysis:</strong> Focus on the most interesting findings about random forest performance</li>
<li><strong>Professional presentation:</strong> Clean, readable, and engaging</li>
<li><strong>Concise conclusions:</strong> No AI babble or unnecessary technical jargon</li>
<li><strong>Human insights:</strong> Your interpretation of what the performance improvements actually mean</li>
<li><strong>Practical implications:</strong> When random forests are worth the added complexity</li>
</ul>
<p><strong>What we‚Äôre looking for:</strong> A compelling 2-3 minute read that demonstrates both the power of ensemble learning and the importance of choosing the right tool for the job. :::</p>
</section>
<section id="questions-to-answer-for-75-grade-on-challenge" class="level3">
<h3 class="anchored" data-anchor-id="questions-to-answer-for-75-grade-on-challenge">Questions to Answer for 75% Grade on Challenge</h3>
<ol type="1">
<li><strong>Power of More Trees Analysis:</strong> Provide a clear, well-reasoned analysis of how random forest performance improves with more trees. Your analysis should demonstrate understanding of ensemble learning principles and diminishing returns.</li>
</ol>
</section>
<section id="questions-to-answer-for-85-grade-on-challenge" class="level3">
<h3 class="anchored" data-anchor-id="questions-to-answer-for-85-grade-on-challenge">Questions to Answer for 85% Grade on Challenge</h3>
<ol start="2" type="1">
<li><strong>Overfitting Analysis:</strong> Provide a thorough analysis comparing decision trees vs random forests in terms of overfitting. Your analysis should explain why individual trees overfit while random forests don‚Äôt, and the mechanisms that prevent overfitting in ensemble methods.</li>
</ol>
</section>
<section id="questions-to-answer-for-95-grade-on-challenge" class="level3">
<h3 class="anchored" data-anchor-id="questions-to-answer-for-95-grade-on-challenge">Questions to Answer for 95% Grade on Challenge</h3>
<ol start="3" type="1">
<li><strong>Linear Regression Comparison:</strong> Your analysis should include a clear comparison table and discussion of when random forests are worth the added complexity vs linear regression. Focus on practical implications for real-world applications.</li>
</ol>
</section>
<section id="questions-to-answer-for-100-grade-on-challenge" class="level3">
<h3 class="anchored" data-anchor-id="questions-to-answer-for-100-grade-on-challenge">Questions to Answer for 100% Grade on Challenge</h3>
<ol start="4" type="1">
<li><strong>Professional Presentation:</strong> Your analysis should be written in a professional, engaging style that would be appropriate for a business audience. Use clear visualizations and focus on practical insights rather than technical jargon.</li>
</ol>
<p><strong>75% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Clear analysis of how random forest performance improves with more trees</label></li>
<li><label><input type="checkbox">Discussion of diminishing returns in ensemble learning</label></li>
</ul>
<p><strong>85% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Thorough overfitting analysis comparing decision trees vs random forests</label></li>
<li><label><input type="checkbox">Explanation of mechanisms that prevent overfitting in random forests</label></li>
</ul>
<p><strong>95% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Complete linear regression comparison with clear table</label></li>
<li><label><input type="checkbox">Discussion of when random forests are worth the complexity</label></li>
</ul>
<p><strong>100% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Professional presentation style appropriate for business audience</label></li>
<li><label><input type="checkbox">Clear, engaging narrative that tells a compelling story</label></li>
<li><label><input type="checkbox">Practical insights that would help a real data scientist</label></li>
</ul>
<p><strong>Report Quality (Critical for Higher Grades):</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Clear, engaging narrative that tells a story</label></li>
<li><label><input type="checkbox">Focus on the most interesting findings about ensemble learning</label></li>
<li><label><input type="checkbox">Professional writing style (no AI-generated fluff)</label></li>
<li><label><input type="checkbox">Concise analysis that gets to the point</label></li>
<li><label><input type="checkbox">Practical insights that would help a real data scientist</label></li>
<li><label><input type="checkbox">Well-designed visualizations that support your analysis</label></li>
</ul>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>